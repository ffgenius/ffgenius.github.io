import{_ as a,c as i,o as l,a4 as o}from"./chunks/framework.B8AjFLjL.js";const p=JSON.parse('{"title":"HTML","description":"","frontmatter":{"next":{"text":"CSS","link":"/interview/css"}},"headers":[],"relativePath":"interview/html.md","filePath":"interview/html.md"}'),e={name:"interview/html.md"},t=o('<h1 id="html" tabindex="-1">HTML <a class="header-anchor" href="#html" aria-label="Permalink to &quot;HTML&quot;">​</a></h1><h2 id="src和href区别" tabindex="-1">src和href区别 <a class="header-anchor" href="#src和href区别" aria-label="Permalink to &quot;src和href区别&quot;">​</a></h2><ol><li>href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系。</li><li>src表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。</li></ol><h2 id="link和-import的区别" tabindex="-1">link和@import的区别 <a class="header-anchor" href="#link和-import的区别" aria-label="Permalink to &quot;link和@import的区别&quot;">​</a></h2><ol><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ol><h2 id="meta标签" tabindex="-1">meta标签 <a class="header-anchor" href="#meta标签" aria-label="Permalink to &quot;meta标签&quot;">​</a></h2><ol><li><code>charset</code>，用来描述HTML文档的编码类型</li><li><code>keywords</code>，页面关键词</li><li><code>description</code>，页面描述</li><li><code>refresh</code>，页面重定向和刷新</li><li><code>viewport</code>，适配移动端，可以控制视口的大小和比例</li></ol><h2 id="html5" tabindex="-1">html5 <a class="header-anchor" href="#html5" aria-label="Permalink to &quot;html5&quot;">​</a></h2><ol><li>语义化标签：header、footer、section、nav、aside、article</li><li>增强型表单：input 的多个 type</li><li>新增表单元素：datalist、keygen、output</li><li>新增表单属性：placeholder、required、min 和 max</li><li>音频视频：audio、video</li><li>canvas</li><li>地理定位</li><li>拖拽</li><li>SVG</li><li>本地存储：localStorage - 没有时间限制的数据存储；sessionStorage - 针对一个 session 的数据存储，当用户关闭浏览器窗口后，数据会被删除</li><li>新事件：onresize、ondrag、onscroll、onmousewheel、onerror、onplay、onpause</li><li>WebSocket：单个 TCP 连接上进行全双工通讯的协议</li></ol><h2 id="sessionstorage-、localstorage和-cookie之间的区别" tabindex="-1">sessionStorage 、localStorage和 cookie之间的区别 <a class="header-anchor" href="#sessionstorage-、localstorage和-cookie之间的区别" aria-label="Permalink to &quot;sessionStorage 、localStorage和 cookie之间的区别&quot;">​</a></h2><h3 id="共同点-都是保存在浏览器端-且同源的" tabindex="-1">共同点：都是保存在浏览器端，且同源的 <a class="header-anchor" href="#共同点-都是保存在浏览器端-且同源的" aria-label="Permalink to &quot;共同点：都是保存在浏览器端，且同源的&quot;">​</a></h3><h3 id="区别" tabindex="-1">区别： <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别：&quot;">​</a></h3><ol><li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。</li><li>存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li><li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li><li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li></ol><h2 id="渐进增强与优雅降级" tabindex="-1">渐进增强与优雅降级 <a class="header-anchor" href="#渐进增强与优雅降级" aria-label="Permalink to &quot;渐进增强与优雅降级&quot;">​</a></h2><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。</p><p>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><h2 id="iframe的优缺点" tabindex="-1">iframe的优缺点 <a class="header-anchor" href="#iframe的优缺点" aria-label="Permalink to &quot;iframe的优缺点&quot;">​</a></h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><h3 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h3><ol><li>可以用来加载速度较慢的内容（如广告）。</li><li>可以使脚本并行下载。</li><li>可以实现跨子域tongxin</li></ol><h3 id="缺点" tabindex="-1">缺点： <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点：&quot;">​</a></h3><ol><li>iframe 会阻塞主页面的 onload 事件。</li><li>无法被一些搜索引擎索识别。</li><li>会产生很多页面，不容易管理。</li></ol><h2 id="bfc" tabindex="-1">BFC <a class="header-anchor" href="#bfc" aria-label="Permalink to &quot;BFC&quot;">​</a></h2><p>BFC块级格式化上下文。BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。</p><ol><li>position:absolute或fixed；</li><li>float:left/right;</li><li>overflow:hidden;</li><li>display:inline-block；</li></ol><h2 id="严格模式与混杂模式" tabindex="-1">严格模式与混杂模式 <a class="header-anchor" href="#严格模式与混杂模式" aria-label="Permalink to &quot;严格模式与混杂模式&quot;">​</a></h2><ol><li>严格模式：以浏览器支持的最高标准运行。</li><li>混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。</li></ol><h2 id="canvas-和-svg-有什么区别" tabindex="-1">Canvas 和 SVG 有什么区别 <a class="header-anchor" href="#canvas-和-svg-有什么区别" aria-label="Permalink to &quot;Canvas 和 SVG 有什么区别&quot;">​</a></h2><p>Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。</p><h3 id="canvas" tabindex="-1">Canvas <a class="header-anchor" href="#canvas" aria-label="Permalink to &quot;Canvas&quot;">​</a></h3><ol><li>通过 Javascript 来绘制 2D 图形。</li><li>是逐像素进行渲染的。</li><li>其位置发生改变，会重新进行绘制。</li></ol><h3 id="svg" tabindex="-1">SVG <a class="header-anchor" href="#svg" aria-label="Permalink to &quot;SVG&quot;">​</a></h3><ol><li>一种使用 XML 描述的 2D 图形的语言。</li><li>SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。</li><li>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</li></ol><h3 id="比较" tabindex="-1">比较 <a class="header-anchor" href="#比较" aria-label="Permalink to &quot;比较&quot;">​</a></h3><p><strong>Canvas</strong></p><ol><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ol><p><strong>SVG</strong></p><ol><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ol><h3 id="viewport-属性值" tabindex="-1">Viewport 属性值 <a class="header-anchor" href="#viewport-属性值" aria-label="Permalink to &quot;Viewport 属性值&quot;">​</a></h3><ol><li>width 设置 layout viewport 的宽度，为一个正整数，或字符串&quot;width-device&quot;</li><li>initial-scale 设置页面的初始缩放值，为一个数字，可以带小数</li><li>minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数</li><li>maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数</li><li>height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用</li><li>user-scalable 是否允许用户进行缩放，值为&quot;no&quot;或&quot;yes&quot;, no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。</li></ol><h2 id="重排与重绘" tabindex="-1">重排与重绘 <a class="header-anchor" href="#重排与重绘" aria-label="Permalink to &quot;重排与重绘&quot;">​</a></h2><p><strong>重排：</strong> 渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。&quot;重绘&quot;不一定需要&quot;重排&quot;，比如改变某个网页元素的颜色，就只会触发&quot;重绘&quot;，不会触发&quot;重排&quot;，因为布局没有改变。 但是，&quot;重排&quot;必然导致&quot;重绘&quot;，比如改变一个网页元素的位置，就会同时触发&quot;重排&quot;和&quot;重绘&quot;，因为布局改变了。</p><p><strong>重绘：</strong> 重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制， 使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。</p>',43),r=[t];function s(n,h,c,d,u,m){return l(),i("div",null,r)}const k=a(e,[["render",s]]);export{p as __pageData,k as default};
